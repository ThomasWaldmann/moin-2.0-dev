======================================================
 Thoughts on lock-free implementation of storage code
======================================================

Prerequisites:
 1) implement proper backend semantics so you can actually return an Item
    object from the backend that references the item via a unique ID or
    file descriptor. See BUGS file, docs/CHANGES.storage and comments in
    sql1.py


 Creating a new item
=====================

create_item will simply return an Item object that knows the requested
item name.

You then populate this item by creating a revision, adding data and
metadata etc. With help of the Revision objects, the Item object keeps track
of changes done that need to be synced to the database (i.e. new data etc.)

Finally, when the object is populated as required, it is saved by way of a
save() method. This method must be implemented atomically by the backend and
may fail with various errors, in this case ItemAlreadyExistsError() if the
item was created by another user in the meantime.

Note that this is rather unlikely.


 How to implement
------------------

The atomic save() method of an Item makes things a bit more complicated for
backends. However, it is well possible to do.

A filesystem backend, for example, would simply create an item directory
that isn't retrievable yet, for example call it "_.tmp_item_10928310" and
populate it. When save is called, it can be renamed to the correct name
which may fail (that is the case when the item was created by somebody else)
in which case the temporary item is simply removed completely.

Similarly, for SQL, all data would be committed to the db but the itemname
would be left NULL in the item name table (which means that an item ID is
allocated but the item does not yet exist.) Then, on .save(), the itemname
would be filled in, a database error ('key collision') means that the item
already exists and all database changes can be undone by following the
previously assigned itemid.

Objects should also have a .abort() method that is called instead of saving
when any problem occurs, it should allow calling after .save() and be a
no-op in that case. A destructor could be implemented to help catching
errors (warn when neither .save nor .abort were called.)


 Creating a new revision
=========================

The use case for creating a new revision is that somebody edits a page. This
means that the previous revision is known to the front-end code and edit-
conflict detection can be, as in the create_item case, done trivially with
help of the backend.

This works similarly to create_item but is even easier, see below for how
both would be used.


 Automatic ACL checking
========================

NOTE: not directly related to lock-free operation except that implementing
      lock-free requires dissolving ItemCollection as it is right now and
      that opens up chances for implementing ACl checking better as well.

The current design requires ACL checking to be done at the ItemCollection
level. With the lock-free design, however, this level will need to be
dissolved. Note that the ACL checking requires access to the request (or at
least user and config) object(s), which is a bit strange. See comment in
sql1.py's SQL1.__init__ as well.

Instead of doing ACL checking at the ItemCollection level, an ACL-checking
overlay backend should be introduced that is created for each request and
used throughout (if ACLs are disabled then request.data_backend will simply
be assigned as request.cfg.data_backend).


 Unsupported operations, further considerations
================================================

Not all operations are supported in lock-free mode, for example for the page
backend it will be assumed that each revision is immutable once it is saved.
Due to support for renaming items, it is also permissible to remove an item
completely (that will behave as though the item was renamed) as long as the
item's data is kept around for all read accesses that are still in-progress,
a bit RCU-like[1]. A cleanup should then probably be run after enough grace
period for read accesses, but it is impossible to know when such a period
has elapsed hence not possible to implement automatic cleanup.

Since the same backend code will be used for session and user storage, some
things need to be mutable since you don't want to create user or session
revisions. Since per-item metadata is already mutable, the high higher level
code for twose two should use per-item metadata.

The backend should also reject any attempt to modify an existing revision.

[1] For a filesystem backend, this might not be easily implementable, but
    it wouldn't be a regression, right now if this race happens with a
    rename the reader will simply crash.
    A database backend would keep the item's data around and it would no
    longer be retrievable without knowing the itemid, and a filesystem
    backend could rename the item's folder to one that cannot be created
    in regular operation, e.g. "_deleted-item-12345", before deleting it
    (so that at least the race window is made smaller.) If the openat(2)
    systemcall family is available (Linux since 2.6.16), then things can
    be implemented in a race-free manner.


 edit action/page editor code
==============================

The basic code framework for the page editor would look like
this:

def user_pressed_save_button(...):
    old_revision = form.get('edited-revision', [None])[0]
    itemname = form.get('page-name', [None])[0]

    # check for browser bugs, our form should always contain that
    assert old_revision is not None
    assert itemname is not None

    new_rev = old_revision + 1

    try:
        if old_revision == 0:
            # Must not fail even if item exists already because
            # then atomicity guarantees are lost, the check can
            # only happen when the item is actually saved.
            item = request.data_backend.create_item(itemname)
        else:
            # Can fail with NoSuchItemError
            item = request.data_backend.get_item(itemname)

        # Could fail if revision exists already, but only if
        # remove_revision is not a valid operation for regular
        # operation, otherwise the same as for create_item()
        # [above] applies. create_item() is different though
        # because of renames, revisions cannot be renamed and
        # thus do not disappear in regular operation unless
        # remove_revision() is allowed.
        revision = item.create_revision(new_rev)

        # fill in revision data (probably calls another function
        # instead that parses the form data etc.)
        revision.meta['...'] = '...'
        revision.data.write('...')

        # Fail here if item or revision now exists. If the item
        # was renamed between getting a reference above and here
        # we'll save the new data to same, but now renamed, item
        # (where the backend allows, might actually fail with a
        # NoSuchItemError.) Of course, usually that will result
        # in getting a RevisionExists error because the rename
        # was done by the UI and hence a new revision was created,
        # in which case the user could be quite confused.
        # handle_edit_conflict() should probably check whether
        # the item still exists at the old name and if not tell
        # the user what happened.
        item.save()
    except RevisionExists:
        # Oops. Somebody else beat us to saving this revision.
        #
        # Invoke edit conflict handling with item (so that we
        # can be sure the item won't disappear between now and
        # looking it up again in handle_edit_conflict())
        self.handle_edit_conflict(item, old_revision)
    except ItemExists, e:
        # Oops. Somebody else beat us to saving this item.
        #
        # Invoke edit conflict handling with the existing item
        # item, backend returns the existing item so we have a
        # chance to use it without somebody renaming it away.
        self.handle_edit_conflict(e.item, old_revision)
    except NoSuchItemError:
        # Oops. Item was renamed (removed?) while we were busy
        # editing it. Ask the user what we should do.
        self.handle_edit_conflict(None, old_revision)
    except PermissionDeniedError:
    	# Raised from the ACL-checking data-backend.
    	#
    	# But how did we get here? We shouldn't have offered the
    	# user the ability to edit this page. Request code will
    	# return a 403 status (with no page text) whenever this
    	# happens. In the regular page display code we of course
    	# catch this error and show the PermissionDeniedPage.
    	raise
    finally:
        # no-op if no modifications were done after .save()
        item.abort()
